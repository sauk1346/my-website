# Total Character in String After Transformations II

You are given a string `s` consisting of lowercase English letters, an integer `t` representing the number of **transformations** to perform, and an array `numbs` of size 26. In one **transformation**, every character in `s` is replaced according to the following rules:

- Replace `s[i]` with the **next** `nums[s[i]-'a']` consecutive characters in the alphabet. For example, if `s[i] = 'a'` and `nums[0] = 3`, the character `'a'`  transforms into the next 3 consecutive characters ahead of it, which results in `"bcd"`.
- The transformation **wraps** around the alphabet if it exceeds `z`. For example, if `s[i] = 'y'` and `nums[24] = 3`, the character `'y'` transforms into the next 3 consecutive characters ahead of it, which results in `"zab"`.

Return the length of the resulting string after **exactly** `t` transformations.

Since the answer may be very large, return it **modulo** `10⁹ + 7`


## Example 1

- **Input:** s = "abcyy", t = 2, nums = [1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,2]
- **Output:** 7
- **Explanation:**

    - **First Transformation (t = 1):**
        - `'a'` becomes `'b'` as `nums[0] == 1`
        - `'b'` becomes `'c'` as `nums[1] == 1`
        - `'c'` becomes `'d'` as `nums[2] == 1`
        - `'y'` becomes `'z'` as `nums[24] == 1`
        - `'y'` becomes `'z'` as `nums[24] == 1`
        - String after the first transformation: `"bcdzz"`
    - **Second Transformation (t = 2):**
        - `'b'` becomes `'c'` as `nums[1] == 1`
        - `'c'` becomes `'d'` as `nums[2] == 1`
        - `'d'` becomes `'e'` as `nums[3] == 1`
        - `'z'` becomes `'ab'` as `nums[25] == 2`
        - `'z'` becomes `'ab'` as `nums[25] == 2`
        - String after the second transformation: `"cdeabab"`

    - Final Length of the string: The string is `"cdeabab"`, which has 7 characters.

## Example 2

- **Input:** s = "azbk", t = 1, nums = [2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2]
- **Output:** 8
- **Explanation:**

    - **First Transformation (t = 1):**
        - `'a'` becomes `'bc'` as `nums[0] == 2`
        - `'z'` becomes `'ab'` as `nums[25] == 2`
        - `'b'` becomes `'cd'` as `nums[1] == 2`
        - `'k'` becomes `'lm'` as `nums[10] == 2`
        - String after the first transformation: `"bcabcdlm"`

    - Final Length of the string: The string is `"bcabcdlm"`, which has 8 characters.

## Solutions

<details>
    <summary>Python</summary>
```python
MOD = 10**9 + 7

class Solution:
    def lengthAfterTransformations(self, s: str, t: int, nums: List[int]) -> int:
 
        T = self.getTransformationMatrix(nums)
        poweredT = self.matrixPow(T, t)

        count = [0] * 26
        lengths = [0] * 26

        for c in s:
            count[ord(c) - ord('a')] += 1

        for i in range(26):
            for j in range(26):
                lengths[j] = (lengths[j] + count[i] * poweredT[i][j]) % MOD

        return sum(lengths) % MOD

    def getTransformationMatrix(self, nums):
        T = [[0] * 26 for _ in range(26)]
        for i in range(len(nums)):
            for step in range(1, nums[i] + 1):
                T[i][(i + step) % 26] += 1
        return T

    def getIdentityMatrix(self, size):
        I = [[0] * size for _ in range(size)]
        for i in range(size):
            I[i][i] = 1
        return I

    def matrixMult(self, A, B):
        size = len(A)
        C = [[0] * size for _ in range(size)]
        for i in range(size):
            for j in range(size):
                for k in range(size):
                    C[i][j] = (C[i][j] + A[i][k] * B[k][j]) % MOD
        return C

    def matrixPow(self, M, n):
        if n == 0:
            return self.getIdentityMatrix(len(M))
        if n % 2 == 1:
            return self.matrixMult(M, self.matrixPow(M, n - 1))
        half = self.matrixPow(M, n // 2)
        return self.matrixMult(half, half)
```

Se puede modelar el problema como un sistema linear utilizando una matriz de transición $T$ de tamaño $26\times 26$, donde cada elemento $T[i][j]$ representa cuántas veces el carácter $a+i$ genera el carácter $a+j$ en una tranformación.

|||
|---|---|
|`getTransformationMatrix(nums)`|Crea una matriz 26x26 mostranto cómo los pasos se mueven de índice a índice según `nums`|
|`getIdentityMatrix(size)`|Genera una matriz de identidad de dimensión `size`|
|`matrixMult(A,B)`|Multiplica 2 matrices modulo `MOD`|
|`MatrixPor(M,n)`|Eleva una matriz `M` a la potencia  `n`|


<h3>Tips</h3>

1. **Conocer el funcionamiento del algoritmo "exponenciación binaria"**

    - Permite reducir los pasos para encontrar un número $a^b$ ($a$ elevado a la potencia de $b$)

```python
# algoritmo exponenciación binaria: a^b
res = 1
while (b > 0):
    if (b%2 == 1):
        res *= a
    
    a = a * a
    b = b / 2

return res
```

2. **Replicar la "exponenciación binaria" a "matrices exponenciales"**

    - Se utiliza la misma idea para así reducir los pasos de ejecución en la resolución de $A^N$ (matriz $A$ elevado a la potencia $N$)

```python
# matriz exponencial
matrix_res = I
while (N):
    if (N%2 == 1):
        res = MatrixMultiply(A,res)

    A = MatrixMultiply(A,A)
    N = N / 2

return matrix_res
```

</details>