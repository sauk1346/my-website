# Two Sum

Given an array of integers `nums` and an integer `target`, return *indices of the two numbers such that they add up to `target`.*

You may assume that each input would have **exactly one solution**, and you may not use the *same* element twice.

You can return the answer in any order.

### Examples 
**Example 1:**
> **Input:** nums = [2, 7, 11, 15], target = 9
> **Output:** [0,1]
> **Explanation:** Because nums[0] + nums[1] == 9, we return [0,1]

**Example 2:**
> **Input:** nums = [3, 2, 4], target = 6
> **Output:** [1,2]

**Example 3:**
> **Input:** nums =[3, 3], target = 6
> **Output:** [0, 1] 

### Constraints

- `2 <= nums.length <= 10⁴`
- `-10⁹ <= nums[i] <= 10⁹`
- `-10⁹ <= target <= 10⁹`
- Only one valid answer exists

### Solutions

<details>
    <summary>Python</summary>
```python
class Solution:
    def twoSum(self, nums: List[int], target: int) -> List[int]:
        seen = {}        
        for i, num in enumerate(nums):
            complement = target - num
            
            if complement in seen:
                return [seen[complement], i]
            
            seen[num] = i
``` 

- Se utiliza un diccionario `seen` para recorrer la lista solo una vez y reducir la complejidad de tiempo a $O(n)$ 
- Se guarda el índice y valor del número recorrido utilizando la el método `enumerate`
- Calculamos el complemento de `num` y los buscamos en `seen`, si no está entonces guardamos `num`
- Se continúa el ciclo hasta que uno de los números guardados sea el complemento del número actual, entonces se retorna el índice del complemento y el  índice del número actual
</details>

<details>
    <summary>JavaScript</summary>
```js
/**
 * @param {number[]} nums
 * @param {number} target
 * @return {number[]}
 */
var twoSum = function(nums, target) {
   const seen = new Map();
    
    for (let i = 0; i < nums.length; i++) {
        const complement = target - nums[i];
        
        if (seen.has(complement)) {
            return [seen.get(complement), i];
        }
        
        seen.set(nums[i], i);
    } 
};
``` 
</details>

<details>
    <summary>Java</summary>
```java
class Solution {
    public int[] twoSum(int[] nums, int target) {
        
        Map<Integer, Integer> seen = new HashMap<>();
        
        for (int i = 0; i < nums.length; i++) {
            int complement = target - nums[i];
            
            if (seen.containsKey(complement)) {
                return new int[] {seen.get(complement), i};
            }
            seen.put(nums[i], i);
        }
        return null;
    }
}
```

- Se utiliza un HashMap para almacenar los números vistos y sus índices
- Si no encuentra los índices retorna null

</details>

<details>
    <summary>C++</summary>
```cpp
class Solution {
public:
    vector<int> twoSum(vector<int>& nums, int target) {
        
        unordered_map<int, int> seen;
        
        for (int i = 0; i < nums.size(); i++) {
            int complement = target - nums[i];
            
            if (seen.find(complement) != seen.end()) {
                return {seen[complement], i};
            }
            seen[nums[i]] = i;
        }
        return {};
    }
};
```

- La función twoSum devuelve un vector de enteros con los índices de los números que cumplen con la condición del problema.
</details>